#!/usr/bin/env perl
use strict;
use warnings;

# this program converts NASM's `insns.dat` to Common Lisp Object System (CLOS) syntax.

my $firstchar;
my $line_length;
my $are_there_square_brackets;
my $mnemonic_and_operands;
my $mnemonic;
my $operands;
my $code_string;
my $flags;

my $clos_object_name;
my $clos_mnemonic;
my $clos_operands;
my $clos_code_string;
my $clos_flags;

my $object_name_length_max;
my $mnemonic_length_max;
my $operands_length_max;
my $code_string_length_max;
my $flags_length_max;

my @object_name_array;
my @mnemonic_array;
my @operands_array;
my @code_string_array;
my @flags_array;

# print the header.
open(FILE, 'ultraelf-lisp-file-header.lisp');

# read one line at once.
while (<FILE>)
{
    print;
}

close(FILE);

# subfunction to get the length of the longest string in an array.
sub longest_length
{
    my $max = -1;
    for (@_)
    {
        if (length > $max)
        {
            $max = length;
        }
    }
    return $max;
}

open(FILE, 'insns.dat');

# read one line at once.
while (<FILE>)
{
    $firstchar = substr($_, 0, 1);
    $line_length = length($_);
    $are_there_square_brackets = ($_ =~ /\[.*\]/);
    chomp;
    if (($line_length > 1) && ($firstchar =~ /[^\t ;]/))
    {
        if ($are_there_square_brackets)
        {
            ($mnemonic_and_operands, $code_string, $flags) = split /[\[\]]+/, $_;
            $code_string = "[" . $code_string . "]";
            ($mnemonic, $operands) = split /[\t ]+/, $mnemonic_and_operands;
        }
        else
        {
            ($mnemonic, $operands, $code_string, $flags) = split /[\t ]+/, $_;
        }
        # find out the following data:
        # object name (Perl syntax): `$mnemonic . "-" . $operands`
        # example object name:        `mov-mem,reg_sreg`
        #
        # fieldname in ultraELF     example
        # :mnemonic                 `"MOV"`
        # :operands                 `"mem,reg_sreg"`
        # :code-string              `"[mr:	8c /r]"`
        # :flags                    `(list "8086" "SW")`
        $mnemonic =~ s/[\t ]+/ /g;
        $operands =~ s/[\t ]+/ /g;
        $code_string =~ s/[\t ]+/ /g;
        $flags =~ s/[\t ]+//g;

        # we don't want non-x86-64 instructions here.
        # they _need_ to be left out, because sometimes the same
        # mnemonic-operands combination has different encodings in x86 and x86-64,
        # and this would also cause identical object names in ultraELF.
        unless ($flags =~ "NOLONG")
        {
            # ok, the content of each field is now filtered,
            # let's convert them to a suitable Common Lisp format.
            
            $clos_object_name = $mnemonic . "-" . $operands;
            
            # in Common Lisp object names `|`, `,`, and `:` must be escaped with a backslash `\`,
            # but that would get too complicated.
            # so we'll simply replace them:
            # `|` -> `-`.
            # `,` -> `.`.
            # `:` -> `.`.
            $clos_object_name =~ s/\|/-/g;              
            $clos_object_name =~ s/,/./g;              
            $clos_object_name =~ s/:/./g;              

            $clos_mnemonic    = "\"" . $mnemonic . "\"";
            $clos_operands    = "\"" . $operands . "\"";
            $clos_code_string = "\"" . $code_string . "\"";
            
            $clos_flags = "\"" . $flags . "\"";        # add first and last double quotes.
            $clos_flags =~ s/,/" "/g;                  # make each flag its own Common Lisp string.
            $clos_flags = "(list " . $clos_flags. ")"; # convert to `list` syntax.
            
            push @object_name_array, $clos_object_name;
            push @mnemonic_array, $clos_mnemonic;
            push @operands_array, $clos_operands;
            push @code_string_array, $clos_code_string;
            push @flags_array, $clos_flags;
        }
    }
}

close(FILE);

# find out maximum length of each field.
$object_name_length_max = longest_length(@object_name_array);
$mnemonic_length_max = longest_length(@mnemonic_array);
$mnemonic_length_max = longest_length(@mnemonic_array);
$operands_length_max = longest_length(@operands_array);
$code_string_length_max = longest_length(@code_string_array);
$flags_length_max = longest_length(@flags_array);

# these objects need be created already during compilation.
printf("(eval-when (:compile-toplevel :load-toplevel :execute)\n");

for (my $i=0; $i <= $#mnemonic_array; $i++)
{
    $clos_object_name = $object_name_array[$i];
    $mnemonic         = $mnemonic_array[$i];
    $operands         = $operands_array[$i];
    $code_string      = $code_string_array[$i];
    $flags            = $flags_array[$i];

    # print the line.
    # actually printed as 5 lines to make it easier to read (for us humans, I mean), with an empty line in the end.
    printf("(setf %s (make-instance 'x86-asm-instruction\n:name %s\n:operands %s\n:code-string %s\n:arch-flags %s))",
        $clos_object_name,
        $mnemonic,
        $operands,
        $code_string,
        $flags);
    if ($i eq $#mnemonic_array)
    {
        printf(")");
    }
    else
    {
        printf("\n\n");
    }
}

exit;
