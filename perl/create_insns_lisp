#!/usr/bin/env perl
use strict;
use warnings;

# this program converts NASM's `insns.dat` to Common Lisp Object System (CLOS) syntax.

my $firstchar;
my $line_length;
my $are_there_square_brackets;
my $mnemonic_and_operands;
my $mnemonic;
my $operands;
my $code_string;
my $flags;
my $mnemonic_of_current_mnemonic_array;

my $clos_object_name;
my $clos_operands;
my $clos_code_string;
my $clos_flags;

my @object_name_array = ();
my @mnemonic_array = ();
my @operands_array = ();
my @code_string_array = ();
my @flags_array = ();

my @each_mnemonic_only_once_array = ();

my @instruction_variants_array = ();
my @instruction_variants_for_current_instruction_array = ();

my $container_class_name;

# print the header.
open(FILE, 'ultraelf-lisp-file-header.lisp');

# read one line at once.
while (<FILE>)
{
    print;
}

close(FILE);

open(FILE, 'insns.dat');

$mnemonic_of_current_mnemonic_array = "";

# read one line at once.
while (<FILE>)
{
    $firstchar = substr($_, 0, 1);
    $line_length = length($_);
    $are_there_square_brackets = ($_ =~ /\[.*\]/);
    chomp;
    if (($line_length > 1) && ($firstchar =~ /[^\t ;]/))
    {
        if ($are_there_square_brackets)
        {
            ($mnemonic_and_operands, $code_string, $flags) = split /[\[\]]+/, $_;
            $code_string = "[" . $code_string . "]";
            ($mnemonic, $operands) = split /[\t ]+/, $mnemonic_and_operands;
        }
        else
        {
            ($mnemonic, $operands, $code_string, $flags) = split /[\t ]+/, $_;
        }
        # find out the following data:
        # object name (Perl syntax): `$mnemonic . "-" . $operands`
        # example object name:        `mov-mem,reg_sreg`
        #
        # fieldname in ultraELF     example
        # :mnemonic                 `"MOV"`
        # :operands                 `"mem,reg_sreg"`
        # :code-string              `"[mr:	8c /r]"`
        # :flags                    `(list "8086" "SW")`
        $mnemonic =~ s/[\t ]+/ /g;
        $operands =~ s/[\t ]+/ /g;
        $code_string =~ s/[\t ]+/ /g;
        $flags =~ s/[\t ]+//g;

        # we don't want non-x86-64 instructions here.
        # they _need_ to be left out, because sometimes the same
        # mnemonic-operands combination has different encodings in x86 and x86-64,
        # and this would also cause identical object names in ultraELF.
        unless ($flags =~ "NOLONG")
        {
            # ok, the content of each field is now filtered,
            # let's convert them to a suitable Common Lisp format.
            
            $clos_object_name = $mnemonic . "-" . $operands;
            
            # in Common Lisp object names `|`, `,`, and `:` must be escaped with a backslash `\`,
            # but that would get too complicated.
            # so we'll simply replace them:
            # `|` -> `-`.
            # `,` -> `.`.
            # `:` -> `.`.
            $clos_object_name =~ s/\|/-/g;
            $clos_object_name =~ s/,/./g;
            $clos_object_name =~ s/:/./g;
            $clos_object_name = "x64-instruction-variant-" . $clos_object_name;

            $clos_operands    = "\"" . $operands . "\"";
            $clos_code_string = "\"" . $code_string . "\"";
            
            $clos_flags = "\"" . $flags . "\"";        # add first and last double quotes.
            $clos_flags =~ s/,/" "/g;                  # make each flag its own Common Lisp string.
            $clos_flags = "(list " . $clos_flags. ")"; # convert to `list` syntax.
            
            push @object_name_array, $clos_object_name;
            push @mnemonic_array, $mnemonic;
            push @operands_array, $clos_operands;
            push @code_string_array, $clos_code_string;
            push @flags_array, $clos_flags;

            if ($mnemonic eq $mnemonic_of_current_mnemonic_array)
            {
                # ok, same mnemonic as the previous one,
                # so the current object name goes to the list.
                push @instruction_variants_for_current_instruction_array, $clos_object_name;
            }
            else
            {
                # ok, this is a new mnemonic.
                # so we'll mark this as current mnemonic.
                $mnemonic_of_current_mnemonic_array = $mnemonic;
                push @each_mnemonic_only_once_array, $mnemonic;

                # we first push the old array (unless it's empty), then clear it,
                # and then push the current object name to the cleared array.

                if (@instruction_variants_for_current_instruction_array)
                {
                    # push the variants array, unless it's empty.
                    push @instruction_variants_array, [ @instruction_variants_for_current_instruction_array ];
                }
                @instruction_variants_for_current_instruction_array = ();
                push @instruction_variants_for_current_instruction_array, $clos_object_name;
            }
        }
    }
}

# the last instruction's instruction variants must be pushed too.
if (@instruction_variants_for_current_instruction_array)
{
    # push the variants array, unless it's empty.
    push @instruction_variants_array, [ @instruction_variants_for_current_instruction_array ];
}

close(FILE);

# print the code to create each container class.

for my $i (0 .. $#instruction_variants_array)
{
    $mnemonic = $each_mnemonic_only_once_array[$i];
    $container_class_name = "x64-" . $mnemonic . "-instruction";

    # print the code to create a container object.
    printf("(defclass %s (x64-asm-instruction) ((name :reader name :initform \"%s\")))\n", $container_class_name, $mnemonic);
    @instruction_variants_for_current_instruction_array = $instruction_variants_array[$i];
}

printf("\n");

# print the code to create each instruction + operands combination object.

for my $i (0 .. $#mnemonic_array)
{
    $clos_object_name = $object_name_array[$i];
    $mnemonic         = $mnemonic_array[$i];
    $operands         = $operands_array[$i];
    $code_string      = $code_string_array[$i];
    $flags            = $flags_array[$i];

    $container_class_name = "x64-" . $mnemonic . "-instruction";

    # print the code to create a variant object.
    # each object here is a variant of a single instruction (or a single mnemonic).
    # actually printed as 5 lines to make it easier to read (for us humans, I mean), with an empty line in the end.
    printf("(defparameter %s (make-instance '%s\n:operands %s\n:code-string %s\n:arch-flags %s))",
        $clos_object_name,
        $container_class_name,
        $operands,
        $code_string,
        $flags);

    if ($i < $#mnemonic_array)
    {
        printf("\n\n");
    }
}

exit;
